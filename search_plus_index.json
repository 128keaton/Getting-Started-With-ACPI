{"./":{"url":"./","title":"Getting Started With ACPI","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Getting started with ACPI A quick explainer on ACPI So what are DSDTs and SSDTs? Well, these are tables present in your firmware that outline hardware devices like USB controllers, CPU threads, embedded controllers, system clocks and such. A DSDT(Differentiated System Description Table) can be seen as the body holding most of the info with smaller bits of info being passed by the SSDT(Secondary System Description Table). You can think of the DSDT as the building blueprints with SSDTs being sticky notes outlining extra details to the project You can read more about ACPI and it's spec here: ACPI 6.3 Manual So why do we care about these tables? macOS can be very picky about the devices present in the DSDT and so our job is to correct it. The main devices that need to be corrected for macOS to work properly: Embedded controllers(EC) All semi-modern intel machines have an EC (usually called H_EC, ECDV, EC0, etc...) exposed in their DSDT, with many AMD systems also having it exposed. These controllers are generally not compatible with macOS and can cause panics, so then need to be hidden from macOS. macOS Catalina requires a device named EC to be present though, so a dummy EC is created. With laptops, the actual embedded controller still needs to be enabled for battery and hotkeys to work, and renaming the EC can additionally cause issues with windows, so creating a fake EC without disabling the real embedded controller is preferable. Plugin type This allows the use of XCPM providing native CPU power management on Intel Haswell and newer CPUs, the SSDT will connect to the first thread of the CPU. Not meant for AMD AWAC system clock. This applies to all 300 series motherboards including many Z370 boards, the specific issue is that newer boards ship with AWAC clock enabled. This is a problem because macOS cannot communicate with AWAC clocks, so this requires us to either force on the legacy RTC clock or if unavailable create a fake one for macOS to play with NVRAM SSDT True 300 series motherboards(non-Z370) don't declare the FW chip as MMIO in ACPI and so the kernel ignores the MMIO region declared by the UEFI memory map. This SSDT brings back NVRAM support Backlight SSDT Used for fixing backlight control support on laptops GPIO SSDT Used for creating a stub to allow VoodooI2C to connect onto, for laptops only XOSI SSDT Used for rerouting OSI calls to this SSDT, mainly used for tricking our hardware into thinking its booting Windows so we get better trackpad support. This is a very hacky solution known for breaking Windows boot, use the GPIO SSDT instead. Usage of XOSI will not be covered in this guide IRQ SSDT and ACPI patches Needed for fixing IRQ conflicts within the DSDT, for laptops mainly. SSDTTime exclusive Note Skylake and newer systems rarely have IRQ conflicts, this is mainly prevalent on Broadwell and older Now head to the next page on what SSDTs do your systems need: Choosing the SSDTs "},"ssdt-platform.html":{"url":"ssdt-platform.html","title":"Choosing the SSDTs","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) What SSDTs do each platform need Please see the specific ACPI section of your config.plist, all SSDTs needed are covered there with a brief explainer. But here's a very quick TL;DR: Desktop High End Desktop Laptop Desktop SSDT IvyBridge Haswell/Broadwell Skylake KabyLake CoffeeLake CometLake AMD(15/16/17h) CPU CPU-PM(Run in Post-Install) SSDT-PLUG SSDT-PLUG SSDT-PLUG SSDT-PLUG SSDT-PLUG N/A EC SSDT-EC SSDT-EC SSDT-EC-USBX SSDT-EC-USBX SSDT-EC-USBX SSDT-EC-USBX SSDT-EC-USBX AWAC N/A N/A N/A N/A SSDT-AWAC SSDT-AWAC N/A NVRAM N/A N/A N/A N/A SSDT-PMC N/A N/A High End Desktop SSDT IvyBridge-E Haswell-E Broadwell-E Skylake-X CPU CPU-PM(Run in Post-Install) SSDT-PLUG SSDT-PLUG SSDT-PLUG EC SSDT-EC SSDT-EC SSDT-EC SSDT-EC-USBX AWAC N/A N/A N/A SSDT-AWAC Laptop SSDT IvyBridge Haswell Broadwell Skylake KabyLake CoffeeLake(8thGen) Coffee/Comet/IceLake(9/10thGen) CPU CPU-PM(Run in Post-Install) SSDT-PLUG SSDT-PLUG SSDT-PLUG SSDT-PLUG SSDT-PLUG SSDT-PLUG EC SSDT-EC SSDT-EC SSDT-EC-USBX SSDT-EC-USBX SSDT-EC-USBX SSDT-EC-USBX SSDT-EC-USBX Backlight SSDT-PNLF SSDT-PNLF SSDT-PNLF SSDT-PNLF SSDT-PNLF SSDT-PNLF-CFL SSDT-PNLF-CFL I2C TrackPad SSDT-GPI0 SSDT-GPI0 SSDT-GPI0 SSDT-GPI0 SSDT-GPI0 SSDT-GPI0 SSDT-GPI0 AWAC N/A N/A N/A N/A N/A N/A SSDT-AWAC NVRAM N/A N/A N/A N/A N/A N/A SSDT-PMC IRQ Patch IRQ SSDT IRQ SSDT IRQ SSDT N/A N/A N/A N/A SSDT Creation "},"ssdt-methods/ssdt-methods.html":{"url":"ssdt-methods/ssdt-methods.html","title":"How to create SSDTs","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) How to create SSDTs Creating SSDTs mainly fall into 3 camps: Prebuilt SSDTs They work but not perfect Automated tools Mainly seen with SSDTTime, work much better though can't cover all situations Manually creating them Will always work, be much cleaner and get to learn about the process "},"ssdt-methods/ssdt-prebuilt.html":{"url":"ssdt-methods/ssdt-prebuilt.html","title":"SSDTs: Prebuilt","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Pre-Built SSDTs Power Management Embedded Controllers Trackpad Backlight System Clock(AWAC) NVRAM(PMC) This is mainly for users who are having troubles either compiling, decompiling or understanding the overal process of ACPI. The main reasons you'd want to avoid is for the following: Slowing down the boot process Mainly because these SSDTs have to go through every possible pathing Fun fact: the prebuilt SSDT-EC-DESKTOP is 42 times larger than making the file yourself Doesn't always work The SSDTs provided can only handle so many situations, and some may in fact not work Mainly seen with SSDT-AWAC, as it assumes there is a way the RTC can be easily enabled Teaches nothing This is the biggest issue as you have no real idea on how to troubleshoot or how to make these files down the line Please refer to Choosing the SSDTs page for which your system needs. Power Management For Haswell and newer: SSDT-PLUG-DRTNIA For Ivy Bridge and older, see the Optimizing Power Management page. This will be done after install. AMD CPU users do not need any SSDTs for power management. Embedded Controllers For desktops: SSDT-EC-USBX-DESKTOP For Skylake and newer and all AMD systems. SSDT-EC-DESKTOP For Broadwell and older. For laptops: SSDT-EC-USBX-LAPTOP For Skylake and newer. SSDT-EC-LAPTOP For Broadwell and older. Trackpad Used for enabling Windows only features in macOS, do note that the below patches will more than likely break Windows booting via OpenCore. I highly encourage you to make one yourself to prevent any issues down the line: Trackpad GPI0 SSDT-XOSI XOSI-Rename.plist Note you'll need to add this into your config.plist under ACPI -> Patch: Comment String Change _OSI to XOSI Enabled Boolean YES Count Number 0 Limit Number 0 Find Data 5f4f5349 Replace Data 584f5349 Backlight For laptops and all-in-one desktops, fixies brightness control support SSDT-PNLF For most users. SSDT-PNLF-CFL For Coffee Lake and newer. System Clock(AWAC) Mainly needed for newer systems running AWAC based system clocks, mainly relavant for Z390 and newer(Gigabyte and AsRock however did backport it to Z370 with a BIOS update) SSDT-AWAC The biggest issue with this prebuilt is that we're just guessing you both have an AWAC clock and that it can be turned off, I highly encourage you to make one yourself to really know whether you both need this and if it's going to work: AWAC vs RTC NVRAM(PMC) Needed to bring back NVRAM support for Z390 and newer, DO NOT USE ON Z370 or older Note: Desktop Z490 boards seem to not need this, though if you're having NVRAM issues you can try this SSDT. SSDT-PMC Reminder only the following need this SSDT: B360 B365 H310 H370 Z390 400 series (Comet Lake) 495 series (Icelake) "},"ssdt-methods/ssdt-easy.html":{"url":"ssdt-methods/ssdt-easy.html","title":"SSDTs: Easy Way","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) SSDTs: The easy way So here we'll be using a super simple tool made by CorpNewt: SSDTTime What this tool does is, it dumps your DSDT from your firmware, and then creates SSDTs based off your DSDT. This must be done on the target machine running either Windows or Linux So what CAN'T SSDTTime do HEDT SSDTs: The ACPI is odd on these platforms so manual work is required This includes X79, X99 and X299 systems Prebuilt can be found here: Embedded Controller Laptop EC fix: This is because you do not want the EC powered off Prebuilt can be found here: Embedded Controller SSDT-PNLF: Need to be configured to your system SSDT-GPI0: Need to be configured to your system AWAC and RTC0 SSDTs: 300 series Intel boards will also need to figure this out (Z390 systems are most common for requiring this but some Gigabyte Z370 do as well) PMC SSDT: For fixing 300 series Intel NVRAM Prebuilt can be found here: NVRAM PMC USBX SSDT: This is included on sample SSDTs but SSDTTime only makes the SSDT-EC part, Skylake and newer users can grab a pre-built here: SSDT-USBX.aml For users who don't have all the options available to them in SSDTTime, you can follow the \"SSDTs: The long way\" section. You can still use SSDTTime for SSDTs it does support. Running SSDTTime Run the SSDTTime.bat file as Admin on the target machine and you should see something like this: What are all these options?: 1. FixHPET - Patch out IRQ Conflicts IRQ patching, mainly needed for X79, X99 and laptop users(use option C to omit conflicting legacy IRQs) 2. FakeEC - OS-aware Fake EC This is the SSDT-EC, required for Catalina users 3. PluginType - Sets plugin-type = 1 on CPU0/PR00 This is the SSDT-PLUG, for Intel only 4. Dump DSDT - Automatically dump the system DSDT Dumps your DSDT from your firmware What we want to do is select option 4. Dump DSDT first, then select the appropriate option(s) for your system. What about USBX? For Skylake and newer plus AMD, you can grab a pre-built file here: SSDT-USBX.aml. This file is plug and play and requires no device configuration, do not use on Broadwell and older. Troubleshooting note: See General Troubleshooting if you're having issues running SSDTTime Adding to OpenCore Don't forget that SSDTs need to be added to Opencore, reminder that .aml is complied, .dsl is code. Add only the .aml file: EFI/OC/ACPI config.plist -> ACPI -> Add Reminder that Cmd/Crtl+R with ProperTree pointed at your OC folder will add all your SSDTs, kexts and .efi drivers to the config for you. Do not add your DSDT to OpenCore, its already in your firmware. If you are unsure what this is referring to, go back to the OpenCore guide and select your config based of the architecture of your CPU. For those who do not yet have a config.plist, you'll want to next head back to your respective OpenCore guides and create the config.plist: OpenCore Desktop guide OpenCore Laptop Guide Users of FixHPET will also need to merge oc_patches.plist into their config.plist Steps to do this: Open both files, Delete the ACPI -> Patch section from config.plist Copy the ACPI -> Patch section from patches.plist Paste into where old patches were in config.plist "},"ssdt-methods/ssdt-long.html":{"url":"ssdt-methods/ssdt-long.html","title":"SSDTs: Long Way","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) SSDTs: The long way Well sadly some things are not handled by SSDTTime, well have no fear as making SSDTs is super easy. The basic process: Dump DSDT(the one SSDTTime did for use will work) Decompile DSDT Make SSDTs based of of it(You'll need either MaciASL or a text editor for this) Compile SSDTs Now continue forth and master the ways of ACPI! "},"Manual/dump.html":{"url":"Manual/dump.html","title":"Dumping the DSDT","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Getting a copy of our DSDT So to start, we'll need to get a copy of your DSDT from your firmware. The easiest way is grabbing the DSDT.aml SSDTTime dumped for us earlier but here are some other options: From Windows: SSDTTime Supports both Windows and Linux for DSDT dumping 4. Dump DSDT - Automatically dump the system DSDT acpidump.exe In command prompt run path/to/acpidump.exe -b -n DSDT -z, this will dump your DSDT as a .dat file. Rename this to DSDT.aml Do note that all ACPI patches from clover/OpenCore will be applied to the DSDT with the above 2 methods From Linux: SSDTTime Supports both Windows and Linux for DSDT dumping 4. Dump DSDT - Automatically dump the system DSDT Do note that all ACPI patches from clover/OpenCore will be applied to the DSDT with the above method From Clover: For those with Clover installed previously, this is a simple way to get your ACPI tables: F4 in Clover Boot menu DSDT can be found in EFI/CLOVER/ACPI/origin, the folder must exist before dumping From OpenCore: With OpenCore 0.5.9, we have a new quirk called SysReport which will actually dump our DSDT automatically when hitting the boot screen. The main issues are: You already need a bootable OpenCore USB to get this dump This also requires a DEBUG version of 0.5.9 For the latter, you just need to replace the following files with DEBUG version: EFI/BOOT/ BOOTx64.efi EFI/OC/Bootstrap/ Bootstrap.efi EFI/OC/Drivers/ OpenRuntime.efi EFI/OC/ OpenCore.efi For the former, you can actually skip the ACPI section, return to the OpenCore guide(Desktop, Laptop) and finish making the USB. Once booted to the picker, you can shut off the PC and check your USB: And voila! You have a DSDT! Now you can continue on with making SSDTs "},"Manual/compile.html":{"url":"Manual/compile.html","title":"Decompiling and Compiling","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Compiling and decompiling ACPI Tables See Troubleshooting if you have dumping/compiling errors macOS Compiling and Decompiling Windows Compiling and Decompiling Linux Compiling and Decompiling macOS So compiling DSDTs and SSDTs are quite easy with macOS, all you need is MaciASL. To compile, just File -> SaveAs -> ACPI Machine Language Binary(.AML), decompiling is just opening the file in MaciASL. For those who prefer the command line, grab iasl-stable and run the following: path/to/iasl.exe path/to/DSDT.aml If compiled .aml file is provided, a decompiled .dsl file will be given and vice versa. Windows Compiling and decompiling on windows is fairly simple though, you will need iasl.exe and Command Prompt: path/to/iasl.exe path/to/DSDT.aml If compiled .aml file is provided, a decompiled .dsl file will be given and vice versa. Linux Compiling and decompiling with Linux is just as simple, you will need a copy of iasl. You can get it here (iasl) or through the iasl package in your package manager. iasl can be used as such: path/to/iasl path/to/DSDT.aml If compiled .aml file is provided, a decompiled .dsl file will be given and vice versa. "},"Desktops/desktop-disable.html":{"url":"Desktops/desktop-disable.html","title":"Disabling desktop dGPUs","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Disabling desktops unsupported GPUs(SSDT-GPU-DISABLE) What this SSDT does Methods to make this SSDT Prebuilt SSDTTime Manual Finding the ACPI path Edits to the sample SSDT Compiling the SSDT So this is mainly needed for GPUs that are not supported in macOS, mainly this will be Nvidia users who wish to pair an AMD GPU for macOS use. While WhateverGreen does support the boot-arg -wegnoegpu, this only works when running on iGPU so for the rest of us we'll need to make an SSDT. So to disable a specific GPU, we need to find a couple things: ACPI Path of the GPU SSDT-GPU-DISABLE Finding the ACPI Path of the GPU To find the PCI path of a GPU is fairly simple, best way to find it is running Windows: Open Device Manager Select Display Adapters, then right click your GPU and select Properties Under the Details Tab, search for \"Location Paths\" Note some GPUs may be hiding under \"BIOS device name\" The second \"ACPI\" is what we care about: ACPI(_SB_)#ACPI(PC02)#ACPI(BR2A)#ACPI(PEGP)#PCI(0000)#PCI(0000) Now converting this to an ACPI path is quite simple, remove the #ACPI and #PCI(0000): `_SB_.PC02.BR2A.PEGP And voila! We've found our ACPI path, now that we have everything we're ready to get cooking Making the SSDT To start grab our SSDT-GPU-DISABLE and open it up. Here there's a couple things to change: External (_SB_.PCI0.PEG0.PEGP, DeviceObj) Method (_SB.PCI0.PEG0.PEGP._DSM, 4, NotSerialized) For our example, we'll change all mentions of : PCI0 with PC02 PEG0 with BR2A Hint: If your ACPI path is a bit shorter than the example, this is fine. Just make sure the ACPI paths are correct to your device, some users may also need to adapt _SB_ to their path Now you're ready to compile the SSDT! "},"Laptops/backlight.html":{"url":"Laptops/backlight.html","title":"Backlight PNLF","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Backlight (SSDT-PNLF) What this SSDT does Methods to make this SSDT What this SSDT does The purpose of this SSDT is to create a PNLF device for macOS to play with, specifically one with a hardware ID of APP0002. Luckily WhateverGreen will handle the rest of the work for us. Methods to make this SSDT For the backlight fix, there are 2 methods you can choose from: Prebuilt Manual "},"Laptops/backlight-methods/prebuilt.html":{"url":"Laptops/backlight-methods/prebuilt.html","title":"Prebuilt","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Backlight: Prebuilt By far the easiest method, all you need to do is download the following file: SSDT-PNLF.aml For most users SSDT-PNLF-CFL.aml For Coffee Lake and newer Main things to note with this method: Assumes GPU pathing, works great for 99% of devices but if you're having issues controlling backlight this may be something to look at Doesn't really teach you anything For most, this doesn't matter. But to some knowing what makes your hackintosh tick is part of the journey "},"Laptops/backlight-methods/manual.html":{"url":"Laptops/backlight-methods/manual.html","title":"Manual","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Backlight: Manual Finding the ACPI path Edits to the sample SSDT Compiling the SSDT Wrapping up Finding the ACPI path For this guide, we're gonna assume Windows is already on this laptop, as otherwise creating this SSDT is a bit more difficult. Now open DeviceManager, and head to the following: Device Manager -> Display Adapters -> Properties -> Details > BIOS device name Note some GPU ACPI pathing may be hiding under \"BIOS device name\" From the above example, we can see our display is hooked up to PCI0.GFX0 Edits to the sample SSDT Now that we have our ACPI path, lets grab our SSDT and get to work: SSDT-PNLF.dsl SSDT-PNLF-CFL.dsl For Coffee Lake and newer By default, this uses PCI0.GFX0 for the pathing. you'll want to rename accordingly. For this example, we'll assume your pathing is PCI0.GPU0: Before: External (_SB_.PCI0.GFX0, DeviceObj) Following the example pathing we found, the SSDT should look something like this: After: External (_SB_.PCI0.GPU0, DeviceObj) Compiling the SSDT With the SSDT done, you're now ready to compile the SSDT! Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Laptops/trackpad.html":{"url":"Laptops/trackpad.html","title":"Trackpad GPI0","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Trackpads (SSDT-GPI0/XOSI) What this SSDT does Methods to make this SSDT What this SSDT does This SSDT is used to force enable our GPI0 for VoodooI2C to connect onto. With most modern laptop DSDTs, there's a variable called GPEN or GPHD which are used for setting the status of the GPI0 device. For us, we want to enable the device. Methods to make this SSDT For the trackpad fix, there are 2 methods you can choose from: Prebuilt Manual "},"Laptops/trackpad-methods/prebuilt.html":{"url":"Laptops/trackpad-methods/prebuilt.html","title":"Prebuilt","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Trackpads: Prebuilt This is a one-size fits all solution where we basically trick our hardware into thinking it's booting Windows. The problem with this method is that it's common to break Windows booting so avoid unless troubleshooting. SSDT-XOSI XOSI Rename(add this under config.plist -> ACPI -> Patch): Comment String Change _OSI to XOSI Enabled Boolean YES Count Number 0 Limit Number 0 Find Data 5f4f5349 Replace Data 584f5349 "},"Laptops/trackpad-methods/manual.html":{"url":"Laptops/trackpad-methods/manual.html","title":"Manual","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Trackpads: Manual Finding the ACPI path Edits to the sample SSDT Compiling the SSDT Wrapping up Finding the ACPI path Finding the ACPI pathing is quite easy actually, first open your decompiled DSDT you got from Dumping the DSDT and Decompiling and Compiling with either maciASL(if in macOS) or any other text editor if in Windows or Linux(VSCode has an ACPI extension that can also help). Next search for Device (GPI0). Should give you a result similar to this: What we care about from this is the _STA method: Method (_STA, 0, NotSerialized) { If ((GPHD == One)) { Return (0x03) } Return (0x0F) } What we want is for this to always return 0x0F when booting macOS, so we want to make an SSDT that will return GPHD == Zero in macOS. NOTE that you may have the other way around where GPHD needs to be set as One to return 0x0F. And your device name may also be different, don't throw random SSDTs in thinking it'll work Here's some more examples: With this example, we can see that we need both SBRG and GPEN to return One. If only one is present, it'll create some issues so in our SSDT we'll want to have both of them return One: Edits to the sample SSDT Now that we have our ACPI path, lets grab our SSDT and get to work: SSDT-GPI0.dsl From the second example, we'll want to set both GPEN and SBRG to One to allow it to operate in macOS: Before: If (_OSI (\"Darwin\")) { GPEN = One Following the example pathing we found, the SSDT should look something like this: After: If (_OSI (\"Darwin\")) { GPEN = One Compiling the SSDT With the SSDT done, you're now ready to compile the SSDT! Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Laptops/laptop-disable.html":{"url":"Laptops/laptop-disable.html","title":"Disabling laptop dGPUs","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Disabling laptop dGPUs (SSDT-dGPU-Off/NoHybGfx) What this SSDT does Methods to make this SSDT Prebuilt SSDTTime Manual Finding the ACPI path Edits to the sample SSDT Compiling the SSDT So with laptops, we can hide the dGPU from macOS with the little boot-arg called -wegnoegpu from WhateverGreen. But one small problem, the dGPU is still pulling power draining your battery slowly. We'll be going over 2 methods for disabling the dGPU in a laptop: Optimus Method Bumblebee Method Note that this is not needed for install, but recommended for post-install Optimus Method How this works is that we call the .off method found on Optimus GPUs, this is the expected way to power off a GPU but some may find their dGPU will power back up later on. Mainly seen in Lenovo's, the Optimus method should work for most users: To start, grab SSDT-dGPU-Off.dsl Next we need to get on Windows, and head to the following: Device Manager -> Display Adapters -> dGPU -> Properties -> Details > BIOS device name Note some GPUs may be hiding under \"BIOS device name\" This should provided you with an ACPI path for your dGPU, most commonly: Nvidia dGPU: \\_SB.PCI0.PEG0.PEGP AMD dGPU: \\_SB.PCI0.PEGP.DGFX Now with that, we'll need to change the ACPI path in the SSDT. Main sections: External(_SB.PCI0.PEG0.PEGP._OFF, MethodObj) If (CondRefOf(\\_SB.PCI0.PEG0.PEGP._OFF)) { \\_SB.PCI0.PEG0.PEGP._OFF() } Once adapted to your config, head to the compile section For those with sleep issues, you can refer to the original Rehabman thread Bumblebee Method With some machines, the simple .off call won't keep the card off properly, that's where the Bumblebee method comes in. This SSDT will actually send the dGPU into D3 state being the lowest power state a device can support. Credit to Mameo for the original adaptation. To start, grab SSDT-NoHybGfx.dsl Next we need to get on Windows, and head to the following: Device Manager -> Display Adapters -> dGPU -> Properties -> Details > BIOS device name This should provided you with an ACPI path for your dGPU, most commonly: Nvidia dGPU: \\_SB.PCI0.PEG0.PEGP AMD dGPU: \\_SB.PCI0.PEGP.DGFX Now with that, we'll need to change the ACPI path in the SSDT. Main sections: External (_SB_.PCI0.PEG0.PEGP._DSM, MethodObj) // dGPU ACPI Path External (_SB_.PCI0.PEG0.PEGP._PS3, MethodObj) // dGPU ACPI Path If ((CondRefOf (\\_SB.PCI0.PEG0.PEGP._DSM) && CondRefOf (\\_SB.PCI0.PEG0.PEGP._PS3))) // Card Off Request \\_SB.PCI0.PEG0.PEGP._DSM (ToUUID (\"a486d8f8-0bda-471b-a72b-6042a6b5bee0\"), 0x0100, 0x1A, Buffer (0x04) // Card Off \\_SB.PCI0.PEG0.PEGP._PS3 () Once adapted to your config, head to the compile section Now you're ready to compile the SSDT! "},"Universal/ec-fix.html":{"url":"Universal/ec-fix.html","title":"Embedded Controller","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Embedded Controller (SSDT-EC/USBX) What this SSDT does Methods to make this SSDT What this SSDT does The purpose of SSDT-EC/UBX is a couple things: On desktops, the EC(or better known as the embedded controller) isn't compatible with AppleACPIEC driver, to get around this we disable this device when running macOS AppleBusPowerController will look for a device named EC, so we will want to create a fake device for this kext to load onto AppleBusPowerController also requires a USBX device to supply USB power properties for Skylake and newer, so we will bundle this device in with the EC fix On laptops, the EC is used for hotkeys and battery so disabling this isn't all too ideal. Problem is our EC's name isn't compatible, so we will create a simple \"fake\" EC device that will satisfy Apple So TL;DR: EC is embedded controller Desktops will want real EC off, and a fake EC created Laptops will just want an additional fale EC present Skylake and newer devices will want USBX as well Methods to make this SSDT For the EC fix, there are 3 methods you can choose from: Prebuilt SSDTTime Note this method does not support laptops, servers or HEDT systems Manual "},"Universal/ec-methods/prebuilt.html":{"url":"Universal/ec-methods/prebuilt.html","title":"Prebuilt","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Embedded Controllers: Prebuilt By far the easiest way to fix your Embedded Controller is just downloading one of the files below: Desktop: SSDT-EC-USBX-DESKTOP For Skylake desktops and newer and AMD CPU based systems SSDT-EC-DESKTOP For Broadwell desktops and older Laptops: SSDT-EC-USBX-LAPTOP.aml For Skylake laptops and newer SSDT-EC-LAPTOP.aml For Broadwell laptops and older The main things to note with this method: Quite Bloated There's ACPI naming for every type, this means there's added delays in boot times Doesn't really teach you anything For most, this doesn't matter. But to some knowing what makes your hackintosh tick is part of the journey Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Universal/ec-methods/ssdttime.html":{"url":"Universal/ec-methods/ssdttime.html","title":"SSDTTime","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Embedded Controllers: SSDTTime The second involves using SSDTTime which automates most of the process. See here on how to use it: SSDTs: Easy Way To get the SSDT-PLUG, run the following: 4. Dump DSDT then run 2. FakeEC This will provide you with some files, the main one you care about is SSDT-EC.aml. The DSDT and .dsl are only left for referencing or verification. The main things to note with this method: Doesn't work on HEDT and server hardware(ie. X99 and X299) While the majority following this guide are likely on consumer hardware, those with fancier hardware will need to either use the Prebuilt or Manual method Doesn't work on Laptops Just like with HEDT, you will need to either use the Prebuilt or Manual method Doesn't provide you the USBX property to fix power This can easily be fixed by using this prebuilt file in addition to SSDT-EC: SSDT-USBX.aml Note USBX is only needed for Skylake and newer Doesn't really teach you anything For most, this doesn't matter. But to some knowing what makes your hackintosh tick is part of the journey Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Universal/ec-methods/manual.html":{"url":"Universal/ec-methods/manual.html","title":"Manual","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Embedded Controllers: Manual Finding the ACPI path DSDT DeviceManager Edits to the sample SSDT Edge Cases Compiling the SSDT Wrapping up TO-DO: Finish Edge cases and sample SSDT edits Finding the ACPI path To find the ACPI pathing, you have 2 methods: DSDT DeviceManager DSDT Finding the ACPI pathing is quite easy actually, first open your decompiled DSDT you got from Dumping the DSDT and Decompiling and Compiling with either maciASL(if in macOS) or any other text editor if in Windows or Linux(VSCode has an ACPI extension that can also help). Next, search for PNP0C09. You should get something similar: From the above example we see 2 main things: Name of our embedded controller In this case being EC0 Pathing of our embedded controller PC00.LPC0 But now we get into edge case territory, what fun! The main ones to check for are: Multiple PNP0C09's show up No PNP0C09 show up PNP0C09 already named EC PNP0C09 already has an _STA method If none of the above apply to you, you're ready for the next section: DeviceManager If you already have Windows installed on this machine, finding the EC pathing is fairly easy. Start by opening up Device Manager in Windows and looking for a device named Embedded Controller. Once found, click on it and select the BIOS device Name entry. You should get something like this: From the above, we can see that our pathing is SB.PC00.LPC0.EC0 Now with the pathing, you can head here: Edits to the sample SSDT Edits to the sample SSDT Now that we have our ACPI path, lets grab our SSDT and get to work: SSDT-EC-USBX For Skylake and newer and all AMD systems SSDT-EC For Broadwell and older Now when opening this SSDT, you'll notice a few things. Mainly: Some code is commented out This is code for disabling our EC Laptops users SHOULD NOT uncomment this There's a new EC called Device (EC) DO NOT RENAME THIS, this will be the EC we give to macOS Before: External (_SB_.PCI0.LPCB, DeviceObj) Following the example pathing we found, the SSDT should look something like this: After: External (_SB_.PC00.LPC0, DeviceObj) Edge Cases Multiple PNP0C09's show up When multiple PNP0C09 show up, we need to next check for the following properties: _HID (Hardware ID) _CRS (Current Resource Settings) _GPE (General Purpose Events) What these signify is whether this PNP0C09 device is real or not, as per the ACPI spec. So one's matching the above criteria are the one's we want to disable. Note: If _STA shows up as well, you'll need to go here: PNP0C09 already has an _STA method No PNP0C09 show up When this happens, you'll only need to create a \"dummy\" EC for macOS. You'll still want to find the PCI and LPC pathing for this device. So follow the guide as if you were creating a laptop SSDT-EC. PNP0C09 already named EC Congrats! No need to create an SSDT-EC! However you will still want USBX if you're skylake or newer. Prebuilt can be grabbed here: SSDT-USBX.aml PNP0C09 already has an _STA method This is the equivalent of not having an EC as we can't control it with our SSDT-EC, instead we'll need to create a \"dummy\" EC for macOS. You'll still want to find the PCI and LPC pathing for this device. So follow the guide as if you were creating a laptop SSDT-EC. Example of an EC with STA already: Compiling the SSDT With the SSDT done, you're now ready to compile the SSDT! Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Universal/plug.html":{"url":"Universal/plug.html","title":"Plugin type","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Power Management (SSDT-PLUG) What this SSDT does Methods to make this SSDT What this SSDT does The purpose of SSDT-PLUG is to allow the kernel's XCPM(XNU's CPU Power Management) to manage our CPU's power management. It's pretty self explanatory why you'd want this. Note: SSDT-PLUG is only compatible with Intel's Haswell and newer CPUs, Sandy Bridge and Ivy Bridge will need to follow the ssdtPRgen method(in post-install) while AMD users should not use this(unless attempting to attach AGPM which is outside the scope of Dortania's guides) Methods to make this SSDT For SSDT-PLUG, there are 3 methods you can choose from: Prebuilt SSDTTime Note this method does not support servers or HEDT systems Manual "},"Universal/plug-methods/prebuilt.html":{"url":"Universal/plug-methods/prebuilt.html","title":"Prebuilt","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Power Management: Prebuilt By far the easiest way to get SSDT-PLUG is just downloading the below file: SSDT-PLUG-DRTNIA.aml This prebuilt file is just a precompiled version of SSDT-PLUG provided by Acidanthera. The main things to note with this method: Quite Bloated There's ACPI naming for every type, this means there's added delays in boot times(though unnoticeable to most as it's generally 0.5 seconds longer) Doesn't really teach you anything For most, this doesn't matter. But to some knowing what makes your hackintosh tick is part of the journey Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Universal/plug-methods/ssdttime.html":{"url":"Universal/plug-methods/ssdttime.html","title":"SSDTTime","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Power Management: SSDTTime The second involves using SSDTTime which automates most of the process. See here on how to use it: SSDTs: Easy Way To get the SSDT-PLUG, run the following: 4. Dump DSDT then run 3. PluginType This will provide you with some files, the main one you care about is SSDT-PLUG.aml. The DSDT and .dsl are only left for referencing or verification. The main things to note with this method: Doesn't work on HEDT and server hardware(ie. X99 and X299) While the majority following this guide are likely on consumer hardware, those with fancier hardware will need to either use the Prebuilt or Manual method Doesn't really teach you anything For most, this doesn't matter. But to some knowing what makes your hackintosh tick is part of the journey Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Universal/plug-methods/manual.html":{"url":"Universal/plug-methods/manual.html","title":"Manual","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing Power Management: Manual Finding the ACPI path DSDT DeviceManager Edits to the sample SSDT Compiling the SSDT Wrapping up Finding the ACPI path To find the ACPI pathing, you have 2 methods: DSDT DeviceManager DSDT CPU naming is fairly easy to figure out, first open your decompiled DSDT you got from Dumping the DSDT and Decompiling and Compiling with either maciASL(if in macOS) or any other text editor if in Windows or Linux(VSCode has an ACPI extension that can also help). Next search for Processor. This should give you a result like this: As we can see, the first processor in our list is SB.PR00. This is what we'll be applying the plugin-type=1 property too. X99 and X299 note: Due to the different DSDT structure of these systems, you'll need to to actually check in multiple places as the pathing isn't as obvious: If we then search for instances of CP00 we find that its full ACPI pathing is SB.SCK0.CP00: Now with the pathing, you can head here: Edits to the sample SSDT DeviceManager If you already have Windows installed on this machine, finding the CPU pathing is fairly easy. Start by opening up Device Manager in Windows and looking for a device named Processor. Once found, click on it and select the BIOS device Name entry. You should get something like this: From the above, we can see that our pathing is PR.CPU0. Pay close attention to the start as PR is important for creating the SSDT X99 and X299 note: Odd quirk of DeviceManager in Windows is that the Processor's order does not actually match the ACPI path, instead giving something like SB.SCK0.CP10: When this happens, you can either: Look through and find the lowest value Assume the lowest(commonly being PR00 or CP00) So with the above X299 example, our CPU pathing would be SB.SCK0.CP00 Now with the pathing, you can head here: Edits to the sample SSDT Edits to the sample SSDT Now that we have our ACPI path, lets grab our SSDT and get to work: SSDT-PLUG.dsl From the above SSDT, it's very likely your processor is already there. If so, you can delete all the other entries other than yours and the Method PMPM as this is what injects the plugin-type=1 property into our system. Reminder: We only need to apply plugin-type=1 to the first thread For the below example, we'll be using the X299 example(SB.SCK0.CP00) Original Cleaned Up Compiling the SSDT With the SSDT done, you're now ready to compile the SSDT! Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Universal/awac.html":{"url":"Universal/awac.html","title":"AWAC vs RTC","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing System Clocks (SSDT-AWAC/RTC0) What this SSDT does Methods to make this SSDT What this SSDT does The purpose of SSDT-AWAC/RTC0 is to fix the system clocks found on newer hardware, maily found in the following: B360 B365 H310 H370 Z370 (Gigabyte and AsRock boards with newer BIOS versions) Z390 B460 Z490 400 series (Comet Lake, including Z490) 495 series (Icelake) X299X (10th Gen refresh, AsRock and Asus don't use the -x naming so you'll need to double check) SSDT-AWAC tries to re-enable the old RTC clock that is compatible with macOS, while SSDT-RTC0 will instead create a \"fake\" RTC clock if there is no legacy one to enable. Methods to make this SSDT For the RTC fix, there are 2 methods you can choose from: Prebuilt Manual "},"Universal/awac-methods/prebuilt.html":{"url":"Universal/awac-methods/prebuilt.html","title":"Prebuilt","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing System Clocks: Prebuilt By far the easiest method, all you need to do is download the following file: SSDT-AWAC.aml Main things to note with this method: Assumes you both have an AWAC clock and it can be easily turned off with the RTC replacing it, this may not always work Doesn't really teach you anything For most, this doesn't matter. But to some knowing what makes your hackintosh tick is part of the journey Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Universal/awac-methods/manual.html":{"url":"Universal/awac-methods/manual.html","title":"Manual","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing System Clocks: Manual Determining which SSDT you need RTC0 Method Finding the ACPI path Edits to the sample SSDT Compiling the SSDT Wrapping up Determining which SSDT you need Finding which SSDT you need is quite easy actually, first open your decompiled DSDT you got from Dumping the DSDT and Decompiling and Compiling with either maciASL(if in macOS) or any other text editor if in Windows or Linux(VSCode has an ACPI extension that can also help). Next search for ACPI000E. You should get something similar: The above tells us a few things: We in fact do have an AWAC clock It can be easily disabled with STAS(if not, you can skip to here: RTC0 Method) _STA is the device status, with Zero meaning it won't show up But to double check, next search for PNP0B00: And looks at that, we can in fact disable our AWAC and enable the RTC! If not skip to here: RTC0 Method Now it's as simple as grabbing SSDt-AWAC.dsl and compile, no changes needed You can also use the below SSDT to the same effect: SSDT-AWAC.aml _INI Edge Cases Mainly seen on X299 refresh boards, there's already a Scope (_SB) { Method (_INI... in your DSDT. This means our SSDT-AWAC will conflict with the one found in our DSDT. For these situations, you'll want to remove Method (_INI, 0, NotSerialized) {} from the SSDT. You'll be left this this in the end: DefinitionBlock (\"\", \"SSDT\", 2, \"DRTNIA\", \"AWAC\", 0x00000000) { External (STAS, IntObj) Scope (_SB) { If (_OSI (\"Darwin\")) { STAS = One } } } RTC0 Method This method is for those who either don't have a PNP0B00 device to re-enable or have no easy way(via STAS variable). Finding the ACPI path Assuming you've gotten your DSDT already opened from earlier, search for the following: Finding the LowPinCount path: Search Name (_ADR, 0x001F0000) Finding the PCI path: Search PNP0A08 (If multiple show up, use the first one) You should get something like the following show up: LPC Pathing PCI Pathing From the above, we can see we have both PCI0 and LPC. Now we can head to the next stage Edits to the sample SSDT Now that we have our ACPI path, lets grab our SSDT and get to work: SSDT-RTC0.dsl By default, this uses PCI0.LPCB for the pathing. you'll want to rename accordingly. Following the example from above, we'll be renaming it to PCI0.LPC: Before: External (_SB_.PCI0.LPCB, DeviceObj) Following the example pathing we found, the SSDT should look something like this: After: External (_SB_.PCI0.LPC, DeviceObj) Compiling the SSDT With the SSDT done, you're now ready to compile the SSDT! Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Universal/nvram.html":{"url":"Universal/nvram.html","title":"NVRAM PMC","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing NVRAM (SSDT-PMC) What this SSDT does Methods to make this SSDT What this SSDT does This SSDT is required for all \"true\" 300 series motherboards and newer(Z370 is excluded), it specifically brings back NVRAM support and requires very little configuration for the end user. B360 B365 H310 H370 Z390 400 series (Cometlake) 495 series (Icelake) Oddly enough, desktop Z490 boards DO NOT need this SSDT. NVRAM just works out of the box for most users, if there's issues though it's recommended to try this SSDT Methods to make this SSDT The main ways to make this SSDT: Prebuilt Manual "},"Universal/nvram-methods/prebuilt.html":{"url":"Universal/nvram-methods/prebuilt.html","title":"Prebuilt","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing NVRAM: Prebuilt By far the easiest method, all you need to do is download the following file: SSDT-PMC.aml Main things to note with this method: Bit Bloated There's ACPI naming for most common paths, this means there's added delays in boot times(though unnoticeable to most as it's generally less than 0.5 seconds longer) Doesn't really teach you anything For most, this doesn't matter. But to some knowing what makes your hackintosh tick is part of the journey Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Universal/nvram-methods/manual.html":{"url":"Universal/nvram-methods/manual.html","title":"Manual","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing NVRAM: Manual Finding the ACPI path Edits to the sample SSDT Compiling the SSDT Wrapping up Finding the ACPI path Finding the ACPI pathing is quite easy actually, first open your decompiled DSDT you got from Dumping the DSDT and Decompiling and Compiling with either maciASL(if in macOS) or any other text editor if in Windows or Linux(VSCode has an ACPI extension that can also help). Next, search for the following: Finding the LowPinCount path: Search Name (_ADR, 0x001F0000) Finding the PCI path: Search PNP0A08 (If multiple show up, use the first one) You should get something like the following show up: LPC Pathing PCI Pathing Now with the pathing, you can head here: Edits to the sample SSDT Edits to the sample SSDT Now that we have our ACPI path, lets grab our SSDT and get to work: SSDT-PMC.dsl By default, this uses PCI0.LPCB for the pathing. you'll want to rename accordingly. Following the example from above, we'll be renaming it to PCI0.LPC: Before: External (_SB_.PCI0.LPCB, DeviceObj) Following the example pathing we found, the SSDT should look something like this: After: External (_SB_.PCI0.LPC, DeviceObj) Compiling the SSDT With the SSDT done, you're now ready to compile the SSDT! Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup "},"Universal/irq.html":{"url":"Universal/irq.html","title":"IRQ Fix","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing IRQ Conflicts (SSDT-HPET + OC_Patches.plist) What this SSDT does Methods to make this SSDT Prebuilt SSDTTime Manual Finding the ACPI path Edits to the sample SSDT Compiling the SSDT So you miss having those fancy hot-patches from Clover like FixIPIC, FixTMR, FixRTC, FixHPET, etc Well 1 very small problem, figuring out IRQ patching is a massive headache. I highly recommend you use SSDTTime. So head over to SSDT: Easy Way on how to make it.(use option C to omit conflicting legacy IRQs) "},"Universal/spoof.html":{"url":"Universal/spoof.html","title":"GPU Spoof","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Renaming GPUs (SSDT-GPU-SPOOF) So this is mainly needed for GPUs that are not natively supported out of the box due to their names, most commonly: R9 290/390 R9 280/380 R7 270/370 R9 260/360 R7 250 R7 240 Instead, these GPUs need to be \"spoofed\" or faked into a model that closely matches theirs, generally this will be the \"X\" variant of the card. For some reason Apple never bothered adding the PCI IDs for these other cards even though their GPU cores are supported by the driver. So to spoof the GPU, we need to find a couple things: Suitable PCI ID for the GPU ACPI Path of the GPU SSDT-GPU-SPOOF Finding a suitable PCI ID To find a suitable PCI ID, we'll be using PCI ID Repository which has a full database of all AMD GPUs. For this example, we'll be creating a Spoof SSDT for the R9 390. For a full list of supported GPUs, please see the GPU Buyers Guide. The closest match to this GPU would be the 390X, and looking on that site near the top gives us this: Vendor 1002 -> Device 1002:67b0 Now lets break this down into a device ID we can use: 1002: The vendor ID, all AMD devices have this ID 67B0: The device ID, this is what we care about So how do we convert this to a fake ID? Well the format of a fake ID: \"device-id\", Buffer (0x04) { 0xB0, 0x67, 0x00, 0x00 }, As you can see, the bytes are swapped in pairs. Keep this in mind when we make our SSDT The specifics are due to Endianness for those who are curious Finding the ACPI Path of the GPU To find the PCI path of a GPU is fairly simple, best way to find it is running Windows: Open Device Manager Select Display Adapters, then right click your GPU and select Properties Under the Details Tab, search for \"Location Paths\" Note some GPUs may be hiding under \"BIOS device name\" The second \"ACPI\" is what we care about: ACPI(_SB_)#ACPI(PC02)#ACPI(BR2A)#ACPI(PEGP)#PCI(0000)#PCI(0000) Now converting this to an ACPI path is quite simple, remove the #ACPI and #PCI(0000): `_SB_.PC02.BR2A.PEGP And voila! We've found our ACPI path, now that we have everything we're ready to get cooking Making the SSDT To start grab our SSDT-GPU-SPOOF and open it up. Here there's a couple things to change: External (_SB_.PCI0, DeviceObj) External (_SB_.PCI0.PEG0.PEGP, DeviceObj) For our example, we'll change all mentions of : PCI0 with PC02 PEG0 with BR2A Hint: If your ACPI path is a bit shorter than the example, this is fine. Just make sure the ACPI paths are correct to your device. Now that the ACPI pathing is correct, we can finally apply our fake ID!!! So the 2 parts we want to change: device ID: \"device-id\", Buffer (0x04) { 0xB0, 0x67, 0x00, 0x00 }, Model: \"model\", Buffer () { \"AMD Radeon R9 390\" } \"device-id\" will be set to our PCI ID that we found in \"Finding a suitable PCI ID\" and \"model\" is mainly cosmetic Now you're ready to compile the SSDT! "},"Universal/smbus.html":{"url":"Universal/smbus.html","title":"Fixing SMBus Support","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing SMBus support (SSDT-SBUS-MCHC) What this SSDT does Methods to make this SSDT What this SSDT does This section of the guide refers to fixing AppleSMBus support in macOS, what is AppleSMBus? Well this mainly handles the System Management Bus, which has many functions like: AppleSMBusController Aids with correct temperature, fan, voltage, ICH, etc readings AppleSMBusPCI Same idea as AppleSMBusController except for low bandwidth PCI devices Memory Reporting Aids in proper memory reporting and can aid in getting better kernel panic details if memory related Other things SMBus does: SMBus wiki For install purposes, this SSDT isn't needed but for post-install it's recommended to put the final touches on your hack. Methods to make this SSDT To make this SSDT, you only got 1 method: Doing it manually Manual "},"Universal/smbus-methods/manual.html":{"url":"Universal/smbus-methods/manual.html","title":"Manual","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Fixing SMBus support: Manual Finding the ACPI path Hackintool DeviceManager Edits to the sample SSDT Compiling the SSDT Wrapping up Finding the ACPI path So to find the ACPI pathing of our SMBus, we've got 2 methods: Hackintool DeviceManager Hackintool To find the correct pathing for your devices, grab Hackintool (Github link) and head to the PCI tab: Look for the SMBus device under Subclass, then look beside and you'll see the ACPI path(under IOReg Name). To convert , omit @... /PC00@0/SMBS@1F,4 -> PC00.SMBS With the ACPI pathing, you can now head here: Edits to the sample SSDT DeviceManager If you already have Windows installed on this machine, finding the SMBus pathing is fairly easy. Start by opening up Device Manager in Windows and looking for a device named SMBUS. Once found, click on it and select the BIOS device Name entry. You should get something like this: From the above example, we can see the SMBus is located at: PC00.SMBS With the ACPI pathing, you can now head here: Edits to the sample SSDT Edits to the sample SSDT Now that we know the ACPI pathing of the SMBus, we can finally start editing the our SSDT. SSDT-SBUS-MCHC.dsl So the important parts we care about are: Before: External (_SB_.PCI0, DeviceObj) Following the example SMBus pathing we found, the SSDT should look something like this: After: External (_SB_.PC00, DeviceObj) Compiling the SSDT With the SSDT done, you're now ready to compile the SSDT! Wrapping up Once you're done making your SSDT, either head to the next page to finish the rest of the SSDTs or head here if you're ready to warp up: Cleanup Verify it's working Once you've installed macOS, you can actually check whether your SSDT-SBUS-MCHC is working or not in terminal: kextstat | grep -E \"AppleSMBusController|AppleSMBusPCI\" "},"cleanup.html":{"url":"cleanup.html","title":"Cleanup","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Cleanup So you've made all your SSDTs but now there's one thing left: Adding them to Opencore The 2 main locations: EFI/OC/ACPI (Only .aml files, reminder to compile your SSDTs) config.plist -> ACPI -> Add You can save yourself some work with the config.plist by running Cmd/Ctrl+R in ProperTree. Reminder do not add your DSDT.aml to your EFI For those who do not yet have a config.plist, you'll want to next head back to your respective OpenCore guides and create the config.plist: OpenCore Desktop guide OpenCore Laptop Guide Users of FixHPET will also need to merge oc_patches.plist into their config.plist Steps to do this: Open both files, Delete the ACPI -> Patch section from config.plist Copy the ACPI -> Patch section from patches.plist Paste into where old patches were in config.plist "},"troubleshooting.html":{"url":"troubleshooting.html","title":"Troubleshooting","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Troubleshooting Fixing SSDTTime: Could not locate or download iasl! Can't run acpidump.efi iASL warning, # unresolved Decompiling Error Invalid character (0x3D), expecting ASL keyword or name Syntax error, unexpected PARSEOP_ONE, expecting '(' Fixing SSDTTime: Could not locate or download iasl! This is usually due to an outdated version of Python, try either updating Python or add iasl to the scripts folder for SSDTTime: iasl macOS version iasl Windows version iasl Linux version Can't run acpidump.efi from OpenCore Grab OpenShell and add it to EFI/OC/Tools and config.plist -> Misc -> Tools. Next, call upon OpenCore shell and enter the following: shell> fs0: //replace with proper drive fs0:\\> dir //to verify this is the right directory Directory of fs0:\\ 01/01/01 3:30p EFI fs0:\\> cd EFI\\OC\\Tools //note that its with forward slashes fs0:\\EFI\\OC\\Tools> acpidump.efi -b -n DSDT -z iASL warning, # unresolved If you try to decompile your DSDT and get an error similar to this: iASL Warning: There were 19 external control methods found during disassembly, but only 0 were resolved (19 unresolved) This happens when one ACPI table requires the rest for proper referencing, it does not accept the creation of DSDTs as we're only using it for creating a select few SSDTs. For those who are worried, you can run the following: iasl * [insert all ACPI files here] Decompiling Error Loading Acpi table from file iASLAwjHrs.aml Acpi table [DSDT] successfully installed and loaded Pass 1 parse of [DSDT] This is a common error on DSDTs that have methods that aren't supported by maciASL, the easiest way is to delete maciASL and make sure you grab it from Acidanthera's repo: maciASL Invalid character (0x3D), expecting ASL keyword or name Similar to the above error, you're running an outdated copy of maciASL. Make sure you're using the latest from Acidanthera's repo: maciASL Syntax error, unexpected PARSEOP_ONE, expecting '(' Similar to the above 2 errors, you're running an outdated copy of maciASL. Make sure you're using the latest from Acidanthera's repo: maciASL "},"CONTRIBUTING.html":{"url":"CONTRIBUTING.html","title":"Contributing","keywords":"","body":" Last modified: Tue Jun 02 2020 13:56:37 GMT+0000 (Coordinated Universal Time) Supporting the guides Note: This is a community run guide which is not officially endorsed by Acidanthera. Please do not bug Acidanthera with issues about this guide. Want to help support the guide? Well there's some ways you can help! Contributing via Issues Contributing via PRs Note: For those wanting to contribute financially, we seriously appreciate it but we're a non-profit organization. We do this to teach, not to make money. If you have some money left over we highly recommend donating it to a charity. Crohn's and Colitis Canada is one we recommend if you have none on mind. Contributing via Issues Contributing via Issues is pretty simple but there are some rules: Keep issues tab dedicated to guides issues only, no personal hackintosh issues. It is not a place to discuss installation issues. If for a typo or better clarification, please indicate what page it was on. Would appreciate not going for a scavenger hunt on where these issues are. You can find the issues tab here: Getting Started With ACPI Issues Contributing via PRs Some guidelines when contributing via PRs: Use your brain (please). Proofread your submissions. Pull Requests can be denied if we feel it does not fit or has inaccurate information. We will generally tell you why it is rejected though or ask for revisions. We would also appreciate sources for any bigger commits to make it easier on us to verify the info your provide is valid Images must be hosted locally in the repo under the /images/ folder Your PR must be run through a markdown lint and have all issues fixed. In general, try to avoid using \"non-Acidanthera\" tools when possible. Generally we want to avoid use of third-party tools - though if it's impossible otherwise, then you can link it. Tools explicitly banned: UniBeast, MultiBeast and KextBeast More info can be found here: Tonymacx86-stance Transmac Know for creating borked USB drives Niresh Installers We'd like to avoid piracy with the guides How to Contribute Best way to test your commits and make sure they are formatted correctly is downloading nodejs and getting the gitbook-cli and markdownlint-cli tools. When you run gitbook serve, it will set up a local webserver which you can connect to view the changes you made. markdownlint * will throw any errors at you about formatting as well, and markdownlint -f * will attempt to fix these. Fork this repo Install the required tools: npm install -g markdownlint-cli npm install -g gitbook-cli Make your changes. Build the site: gitbook install (To install all the required gitbook plugins) gitbook serve (Preview the site) Can be found at http://localhost:4000 Check markdown format: markdownlint -f * (To fix any potential issues) Tips Some tools that make contributing a bit easier: Typora for real time markdown rendering. TextMate for easy and powerful mass find/replace. Github Desktop for more user friendly GUI. "}}